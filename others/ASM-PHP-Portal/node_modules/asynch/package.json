{
  "name": "asynch",
  "version": "0.5.2",
  "description": "Promise-like syntax with explicit callbacks for async",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/baverman/asynch.git"
  },
  "keywords": [
    "async",
    "promise"
  ],
  "author": {
    "name": "Anton Bobrov"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/baverman/asynch/issues"
  },
  "homepage": "https://github.com/baverman/asynch",
  "dependencies": {
    "async": "*"
  },
  "devDependencies": {
    "mocha": "~1.15.0"
  },
  "readme": "# Async helper\n\nYeah we all know about Promise/\\* implementations. But in real life\nwe have to deal with promiseunaware code/libs and thats turns into endless\npain, completely unreadable wrapped wrappers macaroni.\n\nSo explicit callbacks is not a bad thing for now.\n\nAsynch tries to solve a common flow problem â€” you have a bunch of functions.\nSome of them can be run in parallel, others depend from previous results.\nThere is not a problem to directly call async#auto in simple cases. But what\nabout case when you need run parallel tasks after getting result from another\nparallel tasks or run some series in parallel? Hello callbacks hell! \nAsynch allows to linearize such code.\n\n## Quick example\n\n```javascript\nasynch\n.parallel('res1', getRes1)\n.parallel('res2', getRes2)\n.sync('res3', transformRes1Res2IntoRes3)\n.parallel(useOfRes3)\n.parallel(anotherUseOfRes3)\n.done(done)\n```\n\n\n## Result state\n\nEach asynch instance keeps track of intermediate results. You can access it\nas `result` object (then, parallel, sync, done):\n\n```javascript\nasynch\n.then('one', function (cb) { \n    cb(null, 'one')\n})\n.then('two', function (result, cb) {\n    cb(null, result.one + 'two')\n})\n.done(function (err, result) {\n    console.log(result)\n})\n```\n\nOr previous result (thenp, syncp, donep):\n\n```javascript\nasynch\n.then(function (cb) { \n    cb(null, 'one', 'two', 'three')\n})\n.thenp(function (one, two, three, cb) {\n    console.log(three)\n    cb(null, one, two)\n})\n.done(function (err, one, two) {\n    console.log(one, two)\n})\n```\n\nNote: previous result is set by then/thenp/sync/syncp calls only.\nparallel can set return value in result object.\n\nTODO: result.\\_prev\n\n## Basic flow\n\n",
  "readmeFilename": "README.md",
  "_id": "asynch@0.5.2",
  "dist": {
    "shasum": "e4120ccc0c7f7cf7fda56cc21e5b0a37717e4ed0",
    "tarball": "https://registry.npmjs.org/asynch/-/asynch-0.5.2.tgz"
  },
  "_from": "asynch@latest",
  "_npmVersion": "1.3.14",
  "_npmUser": {
    "name": "baverman",
    "email": "bobrov@vl.ru"
  },
  "maintainers": [
    {
      "name": "baverman",
      "email": "bobrov@vl.ru"
    }
  ],
  "directories": {},
  "_shasum": "e4120ccc0c7f7cf7fda56cc21e5b0a37717e4ed0",
  "_resolved": "https://registry.npmjs.org/asynch/-/asynch-0.5.2.tgz"
}
